#include "Tessellation.h"
//#include "TileMatrix.h"

Tessellation::Tessellation(){

}

void Tessellation::update(Tile** tm, int matrix_width, int matrix_height){

}

void Tessellation::morph_into(){

}

tessStaticPoint::tessStaticPoint(){

}

tessBackground::tessBackground(){

}

void tessBackground::setup(Tile** tm, int matrix_width, int matrix_height, int pttrn){
  pattern = pttrn;
  target_state = Tile::DEAD;
  cout << "1.1.1.1" << endl;
  //cout << "1.1.1.1 w: " << matrix_width << endl;
  //cout << "1.1.1.1 h: " << matrix_height << endl;
  switch (pattern){
    case 0:
      for (int i = 0; i < matrix_width; i++){
	for (int j = 0; j < matrix_height; j++){
	  //cout << "1.1.1.2" << i << endl;
	  //cout << "1.1.1.3" << j << endl;
	  tm[i][j].setup(i, j, Tile::DONT_CARE, Tile::DONT_CARE, 1.0, 1.0);
	  //tm[i][j].set_target(Tile::DEAD, 1.0, 1.0);
	}
      }
      break;
    case 1:
      for (int i = 0; i < matrix_width; i++){
	for (int j = 0; j < matrix_height; j++){
	  //cout << "1.1.1.2" << i << endl;
	  //cout << "1.1.1.3" << j << endl;
	  tm[i][j].setup(i, j, Tile::DEAD, Tile::ALIVE, 1.0, 1.0);
	  //tm[i][j].set_target(Tile::ALIVE, 1.0, 1.0);
	}
      }
  }
}

void tessBackground::update(Tile** tm, int matrix_width, int matrix_height){
  //  cout <<"background update" << endl;
  //cout <<"pattern: " << pattern << endl;
  switch(pattern){
    case 0:
      //cout <<"pattern 0" << endl;
      for (int i = 0; i < matrix_width; i++){
	for (int j = 0; j < matrix_height; j++){
	  //tm[i][j].target_state = target_state;
	  tm[i][j].previous_prob_to = tm[i][j].switch_to_target_probability;
	  tm[i][j].previous_prob_from = tm[i][j].switch_from_target_probability;
	  tm[i][j].set_target(Tile::ALIVE, 0.1, 0.0001);
	  //tm[i][j].switch_to_target_probability = 1.0;
	  //tm[i][j].switch_from_target_probability = 0.0;
	}
      }
      break;
    case 1:
      for (int i = 0; i < matrix_width; i++){
	for (int j = 0; j < matrix_height; j++){
	  //tm[i][j].target_state = target_state;
	  tm[i][j].previous_prob_to = tm[i][j].switch_to_target_probability;
	  tm[i][j].previous_prob_from = tm[i][j].switch_from_target_probability;
	  tm[i][j].set_target(Tile::DEAD, 0.0, 1.0);
	  //tm[i][j].switch_to_target_probability = 1.0;
	  //tm[i][j].switch_from_target_probability = 0.0;
	  //tm[i][j].target_state = Tile::ALIVE;
	  ////cout << "1.1.1.2" << i << endl;
	  ////cout << "1.1.1.3" << j << endl;
	}
    }

  }
}

void tessBackground::morph_into(){

}


void tessStaticPoint::update(Tile** tm, int matrix_width, int matrix_height){
  if (!morphing){
    ////cout << "update!" << endl;
    //std:://cout << center_x << "static_point " << center_y <<  " radius: " << radius << endl;
    int minWidth = ((center_x - radius >= 0) ? center_x - radius  : 0 );
    //std:://cout << minWidth << endl;
    int maxWidth = ((center_x + radius < matrix_width) ? center_x + radius : matrix_width - 1);
    //std:://cout << maxWidth << endl;
    int minHeight = ((center_x - radius >= 0) ? center_y - radius  : 0);
    //std:://cout << minHeight << endl;
    int maxHeight = ((center_x + radius < matrix_height) ? center_y + radius : matrix_height - 1);
    //std:://cout << minHeight << endl;
    for (int i = minWidth; i<maxWidth; i++){
      // step through vertically
      for (int j=minHeight; j<maxHeight; j++ ){
	float delta = sqrt(pow(i - center_x, 2.0) + pow(j - center_y, 2.0));
	if (delta < radius){
	  //       	tm[i][j].switch_to_target_probability *= pow(delta/(float) radius, exp);
	  float previous_prob = tm[i][j].previous_prob_to;
	  float previous_prob_from = tm[i][j].previous_prob_from;
	  tm[i][j].switch_to_target_probability = ofLerp(switch_to_target_state,
							 ofLerp(switch_to_target_state,
								previous_prob,
								exp),
							 ((float)(delta))/radius);
	  tm[i][j].switch_from_target_probability = ofLerp(switch_from_target_state,
							 ofLerp(switch_from_target_state,
								previous_prob_from,
								exp),
							 ((float)(delta))/radius);
	}
      }
    }
    
  }
  else {
    float ratio =((float) (ofGetElapsedTimeMillis() - start_time)) /((float) (end_time - start_time));
    int new_center_x = (int) ofLerp(start_state->center_x, end_state->center_x, ratio);
    int new_center_y = (int) ofLerp(start_state->center_y, end_state->center_y, ratio);
    int new_radius = (int) ofLerp(start_state->radius, end_state->radius, ratio);
    float new_to = ofLerp(start_state->switch_to_target_state,
			  end_state->switch_to_target_state,
			  ratio);
    float new_from = ofLerp(start_state->switch_from_target_state,
			    end_state->switch_from_target_state,
			    ratio);
    float new_exp = ofLerp(start_state->exp, end_state->exp, ratio);
      
    int minWidth = ((new_center_x - new_radius >= 0) ? new_center_x - new_radius  : 0 );
    //std:://cout << minWidth << endl;
    int maxWidth = ((new_center_x + new_radius < matrix_width) ? new_center_x + new_radius : matrix_width - 1);
    //std:://cout << maxWidth << endl;
    int minHeight = ((new_center_x - new_radius >= 0) ? new_center_y - new_radius  : 0);
    //std:://cout << minHeight << endl;
    int maxHeight = ((new_center_x + new_radius < matrix_height) ? new_center_y + new_radius : matrix_height - 1);
    //std:://cout << minHeight << endl;
    for (int i = minWidth; i<maxWidth; i++){
      // step through vertically
      for (int j=minHeight; j<maxHeight; j++ ){
	float delta = sqrt(pow(i - new_center_x, 2.0) + pow(j - new_center_y, 2.0));
	if (delta < new_radius){  
	  float previous_prob = tm[i][j].switch_to_target_probability;
	  float previous_prob_from = tm[i][j].switch_from_target_probability;
	  tm[i][j].switch_to_target_probability = ofLerp(new_to,
							 ofLerp(new_to,
								previous_prob,
								new_exp),
							 ((float)(delta))/radius);
	  tm[i][j].switch_from_target_probability = ofLerp(new_from,
							 ofLerp(new_from,
								previous_prob_from,
								new_exp),
							 ((float)(delta))/radius);
	  tm[i][j].target_state = state_lerp(start_state->target_state, end_state->target_state,
					     ratio);
	}
      }
    }
    if (ofGetElapsedTimeMillis() > end_time){
      //start_state = end_state;
      morphing = false;
    }
  }
  
}

void tessStaticPoint::morph_into(tessStaticPoint *sp, float dur){
  morphing = true;
  start_time = ofGetElapsedTimeMillis();
  end_time = start_time + (int) round(dur * 1000);
  start_state = new tessStaticPoint();
  start_state->setup(center_x,
		     center_y,
		     radius,
		     target_state,
		     switch_to_target_state,
		     switch_from_target_state,
                     exp);
  end_state = sp;
}

void Tessellation::setup(){
}

void tessStaticPoint::setup(int coord_x,
			    int coord_y,
			    int _radius,
			    char _state,
			    float _to,
			    float _from,
			    float _exp){
  ////cout << "static point setup" << endl;
  center_x = coord_x;
  center_y = coord_y;
  radius = _radius;
  target_state = _state;
  switch_to_target_state = _to;
  switch_from_target_state = _from;
  exp = _exp;
  
}

tessStaticLine::tessStaticLine(){

}

void tessStaticLine::setup(int coordX_0,
			   int coordY_0,
			   int coordX_1,
			   int coordY_1,			   
			   int _width,
			   char _state,
			   float _to,
			   float _from,
			   float _exp){
  x_0 = coordX_0;
  y_0 = coordY_0;
  x_1 = coordX_1;
  y_1 = coordY_1;
  width = _width;
  state = _state;
  switch_from_target_state = _from;
  switch_to_target_state = _to;
}

void tessStaticLine::update(Tile** tm, int matrix_width, int matrix_height){

}

//not a real lerp, transition from state_begin to state_end through DONT_CARE if they differ
char state_lerp(int state_begin, int state_end, float pos){
  if (state_begin == state_end){
    return state_begin;
  }
  else if (state_begin != Tile::DONT_CARE && state_end !=Tile::DONT_CARE){
    if (pos < 0.33) return state_begin;
    if (pos < 0.67) return Tile::DONT_CARE;
    else return state_end;
  }
  else {
    if (pos < 0.5) return state_begin;
    else return state_end;
  }

}
